conv2d_ext:
    description: |
        Applies a 2D convolution over an input tensor. The input tenor is typically of
        shape :math:`(N, C_{in}, H_{in}, W_{in})`, where :math:`N` is batch size, :math:`C` is
        channel number, :math:`H` is feature height, :math:`W` is feature width.

        The output is calculated based on formula:

        .. math::

            \text{out}(N_i, C_{\text{out}_j}) = \text{bias}(C_{\text{out}_j}) +
            \sum_{k = 0}^{C_{in} - 1} \text{ccor}({\text{weight}(C_{\text{out}_j}, k), \text{X}(N_i, k)})

        where :math:`bias` is the output channel bias, :math:`ccor` is
        the `cross-correlation <https://en.wikipedia.org/wiki/Cross-correlation>`_,
        , :math:`weight` is the convolution kernel value and :math:`X` represents the input feature map.

        Here are the indices' meanings:
        - :math:`i` corresponds to the batch number, ranging from 0 to N-1, where N is the batch size of the input.

        - :math:`j` corresponds to the output channel, ranging from 0 to C_{out}-1, where C_{out} is the number of
        output channels, which is also equal to the number of kernels.

        - :math:`k` corresponds to the input channel, ranging from 0 to C_{in}-1, where C_{in} is the number of
        input channels, which is also equal to the number of channels in the convolutional kernels.

        Therefore, in the above formula, :math:`{bias}(C_{out_j})` represents the bias of the :math:`j`-th
        output channel, :math:`{weight}(C_{out_j}, k)` represents the slice of the :math:`j`-th convolutional
        kernel in the :math:`k`-th channel, and :math:`{X}(N_i, k)` represents the slice of the :math:`k`-th input
        channel in the :math:`i`-th batch of the input feature map.

        The shape of the convolutional kernel is given by :math:`(kernel\_size[0], kernel\_size[1])`,
        where :math:`kernel\_size[0]` and :math:`kernel\_size[1]` are the height and width of the kernel, respectively.
        If we consider the input and output channels as well as the `group` parameter, the complete kernel shape
        will be :math:`(C_{out}, C_{in} / \text{group}, \text{kernel_size[0]}, \text{kernel_size[1]})`,
        where `group` is the number of groups dividing `x`'s input channel when applying group convolution.

        For more details about convolution layer, please refer to `Gradient Based Learning Applied to Document Recognition
        <http://vision.stanford.edu/cs598_spring07/papers/Lecun98.pdf>`_ and
        `ConvNets <http://cs231n.github.io/convolutional-networks/>`_.

        Note:
            On Ascend platform, only group convolution in depthwise convolution scenarios is supported.
            That is, when `groups>1`, condition `C_{in}` = `C_{out}` = `groups` must be satisfied.

        Args:
            input (Tensor): Tensor of shape :math:`(N, C_{in}, H_{in}, W_{in})`.
            weight (Tensor): Tensor of shape
                :math:`(N, C_{in} / \text{groups}, \text{kernel_size[0]}, \text{kernel_size[1]})`, then the size of kernel
                is :math:`(\text{kernel_size[0]}, \text{kernel_size[1]})`.
            bias (Tensor, optional): Bias Tensor with shape :math:`(C_{out})`.
                When bias is ``None`` , zeros will be used. Default: ``None`` .
            stride (Union(int, tuple[int]), optional): The distance of kernel moving, an int number that represents
                the height and width of movement are both strides, or a tuple of two int numbers that
                represent height and width of movement respectively. Default: ``1`` .
            padding (Union(int, tuple[int], list[int]), optional): Implicit paddings on both sides of the input `x`.
                If `padding` is one integer, the paddings of top, bottom, left and right are the same, equal to padding.
                If `padding` is a tuple/list with 2 integers, the padding of top adn bottom is padding[0],
                and the padding of left and right is padding[1]. Default: ``0`` .
            dilation (Union(int, tuple[int]), optional): Gaps between kernel elements.The data type is int or a tuple of
                2 integers. Specifies the dilation rate to use for dilated convolution. If set to be :math:`k > 1`,
                there will be :math:`k - 1` pixels skipped for each sampling location. Its value must
                be greater than or equal to 1 and bounded by the height and width of the input `x`. Default: ``1`` .
            groups (int, optional): Splits `input` into groups. Default: ``1`` .

        Returns:
            Tensor, the value that applied 2D convolution. The shape is :math:`(N, C_{out}, H_{out}, W_{out})`.


        Raises:
            TypeError: If `stride`, `padding` or `dilation` is neither an int nor a tuple.
            TypeError: `groups` is not an int.
            TypeError: If `bias` is not a Tensor.
            ValueError: If  the shape of `bias` is not :math:`C_{out}` .
            ValueError: If `stride` or `dilation` is less than 1.
            ValueError: If `padding` is a tuple/list whose length is not equal to 2.

        Supported Platforms:
            ``Ascend`` ``GPU``

        Examples:
            >>> import mindspore
            >>> import numpy as np
            >>> from mindspore import Tensor, ops
            >>> x = Tensor(np.ones([10, 32, 32, 32]), mindspore.float32)
            >>> weight = Tensor(np.ones([32, 32, 3, 3]), mindspore.float32)
            >>> output = ops.conv2d(x, weight)
            >>> print(output.shape)
            (10, 32, 30, 30)
