# Copyright 2023-2025 Huawei Technologies Co., Ltd
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ============================================================================
"""
Generate operator definition from ops.yaml
"""
import os
import glob
import hashlib
import yaml


py_licence_str = f"""# Copyright 2023 Huawei Technologies Co., Ltd
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ============================================================================
"""
py_header = f"""
\"\"\"Operators definition generated by gen_os.py, includes functions and primitive classes.\"\"\"

from mindspore.ops.primitive import Primitive, prim_attr_register
from mindspore.ops import signature as sig
from mindspore.common import dtype as mstype
from mindspore.ops._primitive_cache import _get_cache_prim
from mindspore.ops_generate.arg_dtype_cast import type_it
from mindspore.ops.auto_generate.gen_arg_handler import *
"""
cc_license_str = f"""/**
 * Copyright 2023 Huawei Technologies Co., Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */"""


def signature_get_rw_label(rw_op_name, write_list, read_list, ref_list):
    """
    Generate signature rw code
    """
    for op in write_list:
        if op == rw_op_name:
            return 'sig.sig_rw.RW_WRITE'
    for op in read_list:
        if op == rw_op_name:
            return 'sig.sig_rw.RW_READ'
    for op in ref_list:
        if op == rw_op_name:
            return 'sig.sig_rw.RW_REF'
    return ''


def signature_get_dtype_label(index):
    """
    Generate signature dtype code
    """
    dtype_index = ''
    if index > 0:
        dtype_index = f"""{index}"""
    return f"""dtype=sig.sig_dtype.T{dtype_index}"""


def generate_py_op_signature(args_signature):
    """
    generate __mindspore_signature__
    """
    if args_signature is None:
        return ''

    signature_code = f"""__mindspore_signature__ = """

    rw_write = args_signature.get('rw_write')
    rw_read = args_signature.get('rw_read')
    rw_ref = args_signature.get('rw_ref')
    dtype_group = args_signature.get('dtype_group')

    if rw_write is None and rw_read is None and rw_ref is None:
        signature_code += '(sig.sig_dtype.T, sig.sig_dtype.T)'
        return signature_code

    # init rw
    rw_write = rw_write.replace(' ', '')
    rw_read = rw_read.replace(' ', '')
    rw_ref = rw_ref.replace(' ', '')
    dtype_group = dtype_group.replace(' ', '')

    write_list = rw_write.split(",")
    read_list = rw_read.split(",")
    ref_list = rw_ref.split(",")
    rw_list = write_list + read_list + ref_list
    rw_items_used = [False for i in range(len(rw_list))]

    # init dtype group
    group_list = []
    same_type_parsed = dtype_group.split("(")
    for item in same_type_parsed:
        if ')' in item:
            parsed = item.split(")")
            group_list.append(parsed[0])


    signature_code += f""" (
"""
    i = 0
    for dtype_group in group_list:
        dtype = signature_get_dtype_label(i)
        i = i + 1

        group_item = dtype_group.split(",")
        for same_type_op in group_item:
            find_writable = False
            for rw_index, rw_op in enumerate(rw_list):
                if rw_op == same_type_op:
                    find_writable = True
                    rw_items_used[rw_index] = True
                    rw_code = signature_get_rw_label(rw_op, write_list, read_list, ref_list)
                    signature_code += f"""     sig.make_sig('{rw_op}', {rw_code}, {dtype}),
"""
            if not find_writable:
                signature_code += f"""     sig.make_sig('{same_type_op}', {dtype}),
"""

    # item has writable but do not has same_type
    for used_index, used_item in enumerate(rw_items_used):
        if not used_item:
            item_name = rw_list[used_index]
            rw_code = signature_get_rw_label(item_name, write_list, read_list, ref_list)
            signature_code += f"""     sig.make_sig('{item_name}', {rw_code}),
"""

    signature_code += f"""    )"""
    return signature_code


def get_op_name(operator_name, class_def):
    """
    Get op name
    """
    class_name = ''.join(word.capitalize() for word in operator_name.split('_'))
    if class_def:
        item = class_def.get("name")
        if item:
            class_name = item
    return class_name


def generate_py_op_func(yaml_data, doc_data):
    """
    generate python operator function
    """
    gen_py = ''

    op_desc_dict = {}
    for operator_name, operator_desc in doc_data.items():
        desc = operator_desc.get("description")
        op_desc_dict[operator_name] = desc

    for operator_name, operator_data in yaml_data.items():
        func_def = operator_data.get('function')
        func_name = operator_name
        func_disable = False
        if func_def:
            item = func_def.get("disable")
            if item:
                func_disable = True

            if func_disable:
                continue
            item = func_def.get("name")
            if item:
                func_name = item

        description = op_desc_dict.get(operator_name)
        args = operator_data.get('args')
        class_name = get_op_name(operator_name, operator_data.get('class'))
        func_args = []
        init_args = []
        input_args = []
        for arg_name, arg_info in args.items():
            init_value = arg_info.get('init')

            if init_value is None:
                func_args.append(arg_name)
                input_args.append(arg_name)
            else:
                if init_value == 'NO_VALUE':
                    func_args.append(f"""{arg_name}""")
                    init_args.append(arg_name)
                else:
                    func_args.append(f"""{arg_name}={init_value}""")
                    init_args.append(arg_name)

        function_code = f"""
def {func_name}({', '.join(arg for arg in func_args)}):
    \"\"\"
    {description}
    \"\"\"
    {operator_name}_op = _get_cache_prim({class_name})({', '.join(arg_name for arg_name in init_args)})
    return {operator_name}_op({', '.join(arg_name for arg_name in input_args)})
"""
        gen_py += function_code

    return gen_py


def get_type_str(type_str):
    """
    get type kind str
    """
    # add more type cast kind here
    type_kind_dict = {
        'int': 'int',
        'tuple[int]': 'tuple',
        'list[int]': 'list',
        'float': 'float',
        'tuple[float]': 'tuple',
        'list[float]': 'list',
        'bool': 'bool',
        'tuple[bool]': 'tuple',
        'list[bool]': 'list',
        'number': 'Number',
        'tensor': 'Tensor',
        'tuple[tensor]': 'tuple',
        'list[tensor]': 'list',
    }
    if type_str in type_kind_dict:
        return type_kind_dict[type_str]
    raise TypeError(f"""Unsupported type {type_str} for args.""")


def process_args(args):
    """process arg for yaml, get arg_name, default value, cast type, pre-handler, etc."""
    args_name = []
    args_assign = []
    init_args_with_default = []
    for arg_name, arg_info in args.items():
        dtype = arg_info.get('dtype')

        init_value = arg_info.get('init')
        if init_value is None:
            continue
        if init_value == 'NO_VALUE':
            init_args_with_default.append(f"""{arg_name}""")
        elif init_value == 'None':
            init_args_with_default.append(f"""{arg_name}={init_value}""")
        else:
            init_args_with_default.append(f"""{arg_name}={init_value}""")
        args_name.append(arg_name)

        assign_str = ""
        type_cast = arg_info.get('type_cast')
        type_cast_set = None
        if type_cast:
            type_cast_set = {ct.strip() for ct in type_cast.split(",")}
        if type_cast_set:
            assign_str += f'type_it({arg_name}, ' + '[' + ', '.join(get_type_str(ct) for ct in type_cast_set) + '], ' \
                          + get_type_str(dtype) + ')'
        else:
            assign_str += arg_name

        arg_handler = arg_info.get('arg_handler')
        if arg_handler is not None:
            assign_str = f'{arg_handler}({assign_str})'

        assign_str = f"""        self._add_prim_arg("{arg_name}", {assign_str})"""
        args_assign.append(assign_str)
    return args_name, args_assign, init_args_with_default


def generate_py_primitive(yaml_data):
    """
    generate python primitive
    """
    gen_py = ''
    for operator_name, operator_data in yaml_data.items():
        signature_code = generate_py_op_signature(operator_data.get('args_signature'))

        args = operator_data.get('args')
        class_name = get_op_name(operator_name, operator_data.get('class'))
        init_args, args_assign, init_args_with_default = process_args(args)
        init_code = '\n'.join(assign for assign in args_assign)

        labels = operator_data.get('labels')
        if labels is not None:
            if init_code != "":
                init_code += "\n"
            init_code += \
                '\n'.join([f"""        self.add_prim_attr("{key}", {value})""" for key, value in labels.items()])
        if init_code == "":
            init_code = f"""        pass"""

        primitive_code = f"""
class {class_name}(Primitive):
    {signature_code}
    @prim_attr_register
    def __init__(self, {', '.join(init_args_with_default) if init_args_with_default else ''}):
{init_code}

    def __call__(self, *args):
        return super().__call__(*args, {', '.join([f'self.{arg}' for arg in init_args])})
"""

        gen_py += primitive_code
    return gen_py


def generate_py_labels(yaml_data):
    """
    generate python labels
    """
    gen_label_py = f"""op_labels = {{"""
    for operator_name, operator_data in yaml_data.items():
        label_dict = operator_data.get('labels')
        if label_dict is not None:
            class_name = get_op_name(operator_name, operator_data.get('class'))
            gen_label_py += f"""
    "{class_name}": {{"""
            gen_label_py += f""", """.join([f""""{key}": {value}""" for key, value in label_dict.items()])
            gen_label_py += f"""}}, """
    gen_label_py += f"""
}}"""
    return gen_label_py


def generate_op_name_opdef(yaml_data):
    """
    generate op name
    """
    op_name_head = f"""
#ifndef MINDSPORE_CORE_OP_NAME_H_
#define MINDSPORE_CORE_OP_NAME_H_

namespace mindspore::ops {{
"""

    op_name_end = f"""}}  // namespace mindspore::ops

#endif  // MINDSPORE_CORE_OP_NAME_H_
"""

    op_name_gen = ''
    op_name_gen += op_name_head
    for operator_name, operator_data in yaml_data.items():
        k_name_op = get_op_name(operator_name, operator_data.get('class'))
        op_name_gen += f"""constexpr auto kName{k_name_op} = "{k_name_op}";
"""

    op_name_gen += op_name_end
    return op_name_gen

def generate_op_prim_opdef(yaml_data):
    """
    generate primitive c++ def
    """
    ops_prim_head = f"""
#ifndef MINDSPORE_CORE_OPS_GEN_OPS_PRIMITIVE_H_
#define MINDSPORE_CORE_OPS_GEN_OPS_PRIMITIVE_H_

#include <memory>
#include "ir/anf.h"
#include "ir/primitive.h"
#include "ops/gen_ops_name.h"
#include "mindapi/base/macros.h"

namespace mindspore::prim {{
"""

    ops_prim_end = f"""}}  // namespace mindspore::prim
#endif  // MINDSPORE_CORE_OPS_GEN_OPS_PRIMITIVE_H_
"""

    ops_prim_gen = ''
    ops_prim_gen += ops_prim_head
    for operator_name, operator_data in yaml_data.items():
        k_name_op = get_op_name(operator_name, operator_data.get('class'))
        ops_prim_gen += f"""GVAR_DEF(PrimitivePtr, kPrim{k_name_op}, std::make_shared<Primitive>(ops::kName{k_name_op}))
"""
    ops_prim_gen += ops_prim_end
    return ops_prim_gen


def generate_lite_ops(yaml_data):
    """
    generate BaseOperator parameter set and get func
    """
    lite_ops_head = f"""
#ifndef MINDSPORE_CORE_OPS_GEN_LITE_OPS_H_
#define MINDSPORE_CORE_OPS_GEN_LITE_OPS_H_

#include "ops/base_operator.h"
#include "ops/gen_ops_name.h"
#include "abstract/abstract_value.h"

namespace mindspore::ops {{
"""

    lite_ops_end = f"""}}  // namespace mindspore::ops
#endif  // MINDSPORE_CORE_OPS_GEN_LITE_OPS_H_
"""

    lite_ops_gen = ''
    lite_ops_gen += lite_ops_head
    for operator_name, operator_data in yaml_data.items():
        OpName = get_op_name(operator_name, operator_data.get('class'))
        lite_ops_gen += f"""class MIND_API {OpName} : public BaseOperator {{
 public:
  {OpName}() : BaseOperator(kName{OpName}) {{}}
"""
        args = operator_data.get('args')
        for _, (arg_name, arg_info) in enumerate(args.items()):
            init = arg_info.get('init')
            if init is None:
                continue

            dtype = arg_info.get('dtype')
            if dtype == "str":
                dtype = "std::string"
            if dtype == "tuple[int]":
                dtype = "std::vector<int64_t>"
            lite_ops_gen += f"""  void set_{arg_name}(const {dtype} &{arg_name}) {{
    (void)this->AddAttr("{arg_name}", api::MakeValue({arg_name}));
  }}
"""
            lite_ops_gen += f"""  {dtype} get_{arg_name}() const {{
    return GetValue<{dtype}>(GetAttr("{arg_name}"));
  }}
"""

        lite_ops_gen += f"""}};

"""
    lite_ops_gen += lite_ops_end
    return lite_ops_gen


def generate_cc_opdef(yaml_data):
    """
    generate OpDef
    """
    opdef_end_code = f"""
}}  // namespace mindspore::ops"""

    func_suffix_str = 'FuncImpl'
    func_impl_dir = 'ops_func_impl'

    gen_cc = f"""

namespace mindspore::ops {{"""
    opdef_map_str = f"""
std::unordered_map<std::string, OpDefPtr> gOpDefTable = {{"""
    gen_include = f"""

#include \"ops/op_def.h\""""

    for operator_name, operator_data in yaml_data.items():
        args = operator_data.get('args')
        returns = operator_data.get('returns')
        class_name = get_op_name(operator_name, operator_data.get('class'))
        opdef_map_str += f"""
    {{"{class_name}", &g{class_name}}},"""
        gen_include += f"""
#include "ops/{func_impl_dir}/{operator_name}.h\""""

        opdef_cc = f"""
{class_name}{func_suffix_str} g{class_name}{func_suffix_str};"""
        opdef_cc += f"""
OpDef g{class_name} = {{
    .name_ = "{operator_name}","""
        opdef_cc += f"""
    .args_ = {{"""
        cc_index_str = f"""
    .indexes_ = {{"""

        for i, (arg_name, arg_info) in enumerate(args.items()):
            dtype = arg_info.get('dtype')
            init = arg_info.get('init')
            init_flag = 0 if init is None else 1
            arg_handler = arg_info.get('arg_handler')
            arg_handler_str = "" if arg_handler is None else arg_handler

            cc_index_str += f"""
                {{"{arg_name}", {i}}},"""
            cc_dtype_str = 'DT_' + dtype.replace('[', '_').\
                replace(']', '').\
                replace('tuple', 'array').\
                replace('list', 'array').upper()

            type_cast = arg_info.get('type_cast')
            type_cast_set = None
            if type_cast:
                type_cast_set = {ct.strip() for ct in type_cast.split(",")}
            if type_cast_set:
                src_type_str = "\"" + '", "'.join(get_type_str(ct) for ct in type_cast_set) + "\""
                dst_type_str = get_type_str(dtype)
            else:
                src_type_str = ""
                dst_type_str = ""

            opdef_cc += f"""
                {{.arg_name_ = "{arg_name}", .arg_dtype_ = {cc_dtype_str}, .as_init_arg_ = {init_flag}, .arg_handler_ = "{arg_handler_str}", 
                .src_cast_dtype_ = {{{src_type_str}}}, .dst_cast_dtype_ = "{dst_type_str}"}},"""
        opdef_cc += f"""
    }},"""

        opdef_cc += f"""
    .returns_ = {{"""

        for return_name, return_info in returns.items():
            return_dtype = return_info.get('dtype')
            cc_return_type_str = 'DT_' + return_dtype.replace('[', '_').replace(']', '').replace(
                'tuple', 'array').replace('list', 'array').upper()
            opdef_cc += f"""
                {{.arg_name_ = "{return_name}", .arg_dtype_ = {cc_return_type_str}}},"""

        opdef_cc += f"""
    }},"""

        cc_index_str += f"""
    }},"""
        opdef_cc += cc_index_str

        cc_func_impl_str = f"""
    .func_impl_ = &g{class_name}{func_suffix_str},"""
        opdef_cc += cc_func_impl_str

        opdef_cc += f"""
}};"""

        gen_cc += opdef_cc

    opdef_map_str += f"""
}};"""
    gen_cc += opdef_map_str

    return gen_include + gen_cc + opdef_end_code


def merge_files_to_one_file(file_names, one_file_name):
    merged_content = ''
    file_names.sort()
    for file_name in file_names:
        with open(file_name, 'r') as file:
            merged_content += file.read()
            merged_content += '\n'
    one_file = open(one_file_name, 'w')
    one_file.write(merged_content)
    one_file.close()


def get_file_md5(file_path):
    """Get the md5 value for file."""
    if not os.path.exists(file_path):
        return ""
    if os.path.isdir(file_path):
        return ""
    with open(file_path, 'rb') as f:
        data = f.read()
    md5_value = hashlib.md5(data).hexdigest()
    return md5_value


def check_change_and_replace_file(last_file_path, tmp_file_path):
    """
    Compare tmp_file with the md5 value of the last generated file.
    If the md5 value is the same, retain the last generated file.
    Otherwise, update the last generated file to tmp_file.
    """
    last_md5 = get_file_md5(last_file_path)
    tmp_md5 = get_file_md5(tmp_file_path)

    if last_md5 == tmp_md5:
        os.system(f'rm {tmp_file_path}')
    else:
        os.system(f'mv {tmp_file_path} {last_file_path}')


def generate_py_code(work_path, yaml_str, doc_str, file_pre):
    """Generate python file from yaml."""
    py_path = os.path.join(work_path, f'mindspore/python/mindspore/ops/auto_generate/{file_pre}_ops_def.py')
    tmp_py_path = os.path.join(work_path, f'mindspore/python/mindspore/ops/auto_generate/tmp_{file_pre}_ops_def.py')

    py_prim = generate_py_primitive(yaml_str)
    py_func = generate_py_op_func(yaml_str, doc_str)

    with open(tmp_py_path, 'w') as py_file:
        py_file.write(py_licence_str + py_header + py_prim + py_func)
    check_change_and_replace_file(py_path, tmp_py_path)


def generate_labels_file(work_path, yaml_str):
    op_py_path = os.path.join(work_path, 'mindspore/python/mindspore/ops/auto_generate/gen_labels.py')
    tmp_op_py_path = os.path.join(work_path, 'mindspore/python/mindspore/ops/auto_generate/tmp_gen_labels.py')
    py_labels = generate_py_labels(yaml_str)
    with open(tmp_op_py_path, 'w') as py_file:
        py_file.write(py_licence_str + "\n" + py_labels + "\n")
    check_change_and_replace_file(op_py_path, tmp_op_py_path)


def generate_cc_code(work_path, yaml_str):
    """Generate c++ file from yaml."""
    # ops_def
    op_cc_path = os.path.join(work_path, 'mindspore/core/ops/gen_ops_def.cc')
    tmp_op_cc_path = os.path.join(work_path, 'mindspore/core/ops/tmp_gen_ops_def.cc')
    cc_def_code = generate_cc_opdef(yaml_str)
    with open(tmp_op_cc_path, 'w') as cc_file:
        cc_file.write(cc_license_str + cc_def_code)
    check_change_and_replace_file(op_cc_path, tmp_op_cc_path)

    # ops_primitive
    op_prim_path = os.path.join(work_path, 'mindspore/core/ops/gen_ops_primitive.h')
    tmp_op_prim_path = os.path.join(work_path, 'mindspore/core/ops/tmp_gen_ops_primitive.h')
    op_prim_code = generate_op_prim_opdef(yaml_str)
    with open(tmp_op_prim_path, 'w') as op_prim_file:
        op_prim_file.write(cc_license_str + op_prim_code)
    check_change_and_replace_file(op_prim_path, tmp_op_prim_path)

    # lite_ops
    lite_ops_path = os.path.join(work_path, 'mindspore/core/ops/gen_lite_ops.h')
    tmp_lite_ops_path = os.path.join(work_path, 'mindspore/core/ops/tmp_gen_lite_ops.h')
    lite_ops_code = generate_lite_ops(yaml_str)
    with open(tmp_lite_ops_path, 'w') as lite_ops_file:
        lite_ops_file.write(cc_license_str + lite_ops_code)
    check_change_and_replace_file(lite_ops_path, tmp_lite_ops_path)

    # ops_names
    op_name_path = os.path.join(work_path, 'mindspore/core/ops/gen_ops_name.h')
    tmp_op_name_path = os.path.join(work_path, 'mindspore/core/ops/tmp_gen_ops_name.h')
    op_name_code = generate_op_name_opdef(yaml_str)
    with open(tmp_op_name_path, 'w') as op_name_file:
        op_name_file.write(cc_license_str + op_name_code)
    check_change_and_replace_file(op_name_path, tmp_op_name_path)


def generate_enum(yaml_data):
    """
    generate python and c++ enum definition
    """
    gen_eum_py_func = ''
    gen_eum_py_def = f"""
\"\"\"Operator argument enum definition.\"\"\"

from enum import Enum
"""
    gen_eum_cc = ''
    eum_cc_head = f"""
#ifndef MINDSPORE_CORE_OPS_GEN_ENUM_DEF_
#define MINDSPORE_CORE_OPS_GEN_ENUM_DEF_

#include <cstdint>

namespace mindspore::ops {{
"""

    eum_cc_end = f"""}}  // namespace mindspore::ops
#endif  // MINDSPORE_CORE_OPS_GEN_ENUM_DEF_
"""
    gen_eum_cc += eum_cc_head

    for enum_name, enum_data in yaml_data.items():
        class_name = ''.join(word.capitalize() for word in enum_name.split('_'))
        enum_py_func_code = f"""
def {enum_name}_to_enum({enum_name}_str):
    {enum_name}_str = {enum_name}_str.upper()
"""
        gen_eum_py_def += f"""

class {class_name}(Enum):
"""
        enum_cc_code = f"""enum class {class_name} : int64_t {{
"""
        for enum_key, enum_value in enum_data.items():
            enum_py_func_code += f"""    if {enum_name}_str == "{enum_key}":
        return {enum_value}
"""
            gen_eum_py_def += f"""    {enum_key} = {enum_value}
"""
            enum_cc_code += f"""    {enum_key} = {enum_value},
"""

        value_error_py = f"""    raise ValueError(f"Invalid {class_name}: {{{enum_name}_str}}")
"""
        gen_eum_py_func += enum_py_func_code + value_error_py + """
"""
        gen_eum_cc += enum_cc_code + f"""}};

"""

    gen_eum_cc += eum_cc_end
    return gen_eum_py_func, gen_eum_py_def, gen_eum_cc


def generate_enum_code(work_path):
    """Generate python function and c++ definition for enum yaml."""
    enum_yaml_path = os.path.join(work_path, 'mindspore/python/mindspore/ops_generate/enum.yaml')
    yaml_str = None
    with open(enum_yaml_path, 'r') as yaml_file:
        yaml_str = yaml.safe_load(yaml_file)
    py_enum_func, py_enum_def, cc_enum = generate_enum(yaml_str)

    src_arg_handler_path = os.path.join(work_path, 'mindspore/python/mindspore/ops_generate/arg_handler.py')
    dst_arg_handler_path = os.path.join(work_path, 'mindspore/python/mindspore/ops/auto_generate/gen_arg_handler.py')
    tmp_dst_arg_handler_path = os.path.join(work_path,
                                            'mindspore/python/mindspore/ops/auto_generate/tmp_gen_arg_handler.py')
    os.system(f'cp {src_arg_handler_path} {tmp_dst_arg_handler_path}')
    with open(tmp_dst_arg_handler_path, 'a') as py_file:
        py_file.write(py_enum_func)
    check_change_and_replace_file(dst_arg_handler_path, tmp_dst_arg_handler_path)

    enum_def_py_path = os.path.join(work_path, 'mindspore/python/mindspore/ops/auto_generate/gen_enum_def.py')
    tmp_enum_def_py_path = os.path.join(work_path, 'mindspore/python/mindspore/ops/auto_generate/tmp_gen_enum_def.py')
    with open(tmp_enum_def_py_path, 'w') as cc_file:
        cc_file.write(py_licence_str + py_enum_def)
    check_change_and_replace_file(enum_def_py_path, tmp_enum_def_py_path)

    enum_def_cc_path = os.path.join(work_path, 'mindspore/core/ops/gen_enum_def.h')
    tmp_enum_def_cc_path = os.path.join(work_path, 'mindspore/core/ops/tmp_gen_enum_def.h')
    with open(tmp_enum_def_cc_path, 'w') as cc_file:
        cc_file.write(cc_license_str + cc_enum)
    check_change_and_replace_file(enum_def_cc_path, tmp_enum_def_cc_path)


def merge_files(origin_dir, dst_file, file_format):
    """ merge_files """
    op_yaml_file_names = glob.glob(os.path.join(origin_dir, file_format))
    merge_files_to_one_file(op_yaml_file_names, dst_file)


def safe_load_yaml_str(yaml_paths):
    """ safe_load_yaml_str """
    yaml_str = dict()
    for yaml_path in yaml_paths:
        with open(yaml_path, 'r') as yaml_file:
            yaml_str.update(yaml.safe_load(yaml_file))
    return yaml_str


def main():
    current_path = os.path.dirname(os.path.abspath(__file__))
    work_path = os.path.join(current_path, '../../../../')

    # ops
    ops_yaml_path = os.path.join(work_path, 'mindspore/python/mindspore/ops_generate/ops.yaml')
    doc_yaml_path = os.path.join(work_path, 'mindspore/python/mindspore/ops_generate/ops_doc.yaml')
    yaml_dir_path = os.path.join(work_path, 'mindspore/core/ops/ops_def/')
    merge_files(yaml_dir_path, ops_yaml_path, '*op.yaml')
    merge_files(yaml_dir_path, doc_yaml_path, '*doc.yaml')

    # inner ops
    inner_ops_yaml_path = os.path.join(work_path, 'mindspore/python/mindspore/ops_generate/inner_ops.yaml')
    inner_doc_yaml_path = os.path.join(work_path, 'mindspore/python/mindspore/ops_generate/inner_ops_doc.yaml')
    inner_yaml_dir_path = os.path.join(work_path, 'mindspore/core/ops/ops_def/inner')
    merge_files(inner_yaml_dir_path, inner_ops_yaml_path, '*op.yaml')
    merge_files(inner_yaml_dir_path, inner_doc_yaml_path, '*doc.yaml')


    # gen python ops files
    all_doc_str = safe_load_yaml_str({doc_yaml_path, inner_doc_yaml_path})
    generate_py_code(work_path, safe_load_yaml_str({ops_yaml_path}), all_doc_str, "gen")
    generate_py_code(work_path, safe_load_yaml_str({inner_ops_yaml_path}), all_doc_str, "gen_inner")


    # all ops gen files
    all_ops_str = safe_load_yaml_str({ops_yaml_path, inner_ops_yaml_path})
    generate_labels_file(work_path, all_ops_str)
    generate_cc_code(work_path, all_ops_str)
    generate_enum_code(work_path)


if __name__ == "__main__":
    main()
